#pragma once\n#include "RogueCity/Core/Types.hpp"\n#include <cmath>\n#include <numbers>\n#include <memory>\n\nnamespace RogueCity::Generators {\n\n    using namespace Core;\n\n    /// Base class for tensor basis field types (Strategy pattern)\n    class BasisField {\n    public:\n        Vec2 center;\n        double radius;\n        double decay;\n\n        BasisField(const Vec2& center, double radius, double decay)\n            : center(center), radius(radius), decay(decay) {}\n\n        virtual ~BasisField() = default;\n\n        /// Sample tensor at world position\n        [[nodiscard]] virtual Tensor2D sample(const Vec2& p) const = 0;\n\n        /// Compute influence weight at position (exponential decay)\n        [[nodiscard]] double getWeight(const Vec2& p) const {\n            double dist = p.distanceTo(center);\n            if (dist > radius) return 0.0;\n            double norm_dist = dist / radius;\n            return std::exp(-decay * norm_dist);\n        }\n    };\n\n    // ===== RADIAL BASIS FIELD (Paris-style) =====\n\n    /// Generates concentric circular roads (e.g., Paris Arc de Triomphe)\n    class RadialField : public BasisField {\n    public:\n        RadialField(const Vec2& center, double radius, double decay)\n            : BasisField(center, radius, decay) {}\n\n        [[nodiscard]] Tensor2D sample(const Vec2& p) const override {\n            Vec2 dir = p - center;\n            double angle = std::atan2(dir.y, dir.x);\n            // Tangent to circle (perpendicular to radius)\n            return Tensor2D::fromAngle(angle + std::numbers::pi * 0.5);\n        }\n    };\n\n    // ===== GRID BASIS FIELD (Manhattan-style) =====\n\n    /// Generates orthogonal grid roads (e.g., Manhattan, Chicago)\n    class GridField : public BasisField {\n    public:\n        double theta;  // Primary grid orientation (radians)\n\n        GridField(const Vec2& center, double radius, double theta, double decay)\n            : BasisField(center, radius, decay), theta(theta) {}\n\n        [[nodiscard]] Tensor2D sample(const Vec2& p) const override {\n            // Alternate between theta and theta + Ï€/2 based on position\n            // Creates orthogonal grid effect\n            int cell_x = static_cast<int>(p.x / 50.0);  // 50m grid cells\n            int cell_y = static_cast<int>(p.y / 50.0);\n            bool use_primary = (cell_x + cell_y) % 2 == 0;\n            \n            double angle = use_primary ? theta : (theta + std::numbers::pi * 0.5);\n            return Tensor2D::fromAngle(angle);\n        }\n    };\n\n    // ===== DELTA BASIS FIELD (Organic 3-way junctions) =====\n\n    enum class DeltaTerminal {\n        North, South, East, West,\n        NorthEast, NorthWest, SouthEast, SouthWest\n    };\n\n    /// Generates organic 3-way intersections (e.g., hillside towns)\n    class DeltaField : public BasisField {\n    public:\n        DeltaTerminal terminal;\n\n        DeltaField(const Vec2& center, double radius, DeltaTerminal terminal, double decay)\n            : BasisField(center, radius, decay), terminal(terminal) {}\n\n        [[nodiscard]] Tensor2D sample(const Vec2& p) const override {\n            // Point toward terminal direction from center\n            Vec2 terminal_dir = getTerminalDirection();\n            Vec2 to_p = p - center;\n            \n            // Blend between radial and terminal direction\n            double blend = std::min(1.0, to_p.length() / radius);\n            Vec2 dir = lerp(to_p, terminal_dir, blend);\n            \n            return Tensor2D::fromVector(dir);\n        }\n\n    private:\n        [[nodiscard]] Vec2 getTerminalDirection() const {\n            switch (terminal) {\n                case DeltaTerminal::North: return Vec2(0, -1);\n                case DeltaTerminal::South: return Vec2(0, 1);\n                case DeltaTerminal::East: return Vec2(1, 0);\n                case DeltaTerminal::West: return Vec2(-1, 0);\n                case DeltaTerminal::NorthEast: return Vec2(0.707, -0.707);\n                case DeltaTerminal::NorthWest: return Vec2(-0.707, -0.707);\n                case DeltaTerminal::SouthEast: return Vec2(0.707, 0.707);\n                case DeltaTerminal::SouthWest: return Vec2(-0.707, 0.707);\n                default: return Vec2(0, 1);\n            }\n        }\n    };\n\n    // ===== GRID CORRECTIVE FIELD (Straightens organic roads) =====\n\n    /// Straightens and gridifies nearby roads (e.g., hybrid planning like DC)\n    class GridCorrectiveField : public BasisField {\n    public:\n        double theta;  // Target grid orientation\n\n        GridCorrectiveField(const Vec2& center, double radius, double theta, double decay)\n            : BasisField(center, radius, decay), theta(theta) {}\n\n        [[nodiscard]] Tensor2D sample(const Vec2& p) const override {\n            // Fix: remove unused parameter warning by casting to void\n            (void)p;\n            // Strong alignment to grid orientation\n            return Tensor2D::fromAngle(theta);\n        }\n    };\n\n} // namespace RogueCity::Generators\n