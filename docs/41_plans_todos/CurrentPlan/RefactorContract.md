You can treat this as a “Gemini 3 Pro playbook” for evolving RogueCities into the hardened, chunked, MDP/Markov-driven architecture described in your docs, with concrete library install steps, integration points, and gotchas.

***

## High-level Gemini 3 Pro contract

When you spin up Gemini as a coding agent, keep these global invariants in every prompt:

- **Canonical namespaces and math**
  - Use `RogueCity::Core` / `RogueCity::Generators` only.
  - Public APIs use `Core::Vec2`, `Core::Bounds`, `WorldConstraintField`; `glm::*` only inside .cpp/private helpers.
  - Respect existing containers: `fva::Container`, `siv::Vector`, etc.

- **Determinism**
  - All procedural algorithms must be deterministic given `(global_seed, chunk_coord, stage_inputs)` so chunks can be regenerated and Markov/MDP logic can be replayed exactly.
  - Never use global RNGs or time-based seeds; key everything from explicit seeds per chunk/layer.

- **Layered, chunked generation**
  - Maintain the staged pipeline: math context → roads/graph (MDP) → blocks/lots (Boost/Clipper2) → frontage Markov → meshes/export.
  - Chunks communicate via lightweight “inbound connection requests,” not by locking or direct cross-chunk reads.

Keep those in the system prompt whenever you ask Gemini to touch core generation code.

***

## Library installation & wiring

### 1. Core geometry & noise stack

These are long‑term residents of the core/generators targets.

**a) Manifold**

- **Use case:** Robust 3D constructive solid geometry (CSG) and manifold fixes on building meshes (boolean ops, union/diff for foundations, tunnels, etc.).
- **Install (vcpkg example):**
  ```powershell
  vcpkg install manifold
  ```
- **Integration:**
  - Link in `RogueCity::RogueCityCore` or a dedicated `RogueCity::MeshOps` module that handles solid operations before export.
  - Restrict Manifold usage to mesh post‑processing / export path, not core 2D planning.

**Edge cases:**
- Input meshes must be watertight and consistently wound; instruct Gemini to add asserts + fix‑up passes (merge close vertices, delete zero‑area faces) before calling Manifold.
- Enforce consistent units (meters) and world origin; avoid huge coordinate magnitudes (scale into a local frame before CSG; scale back after).

***

**b) Clipper2**

- **Use case:** 2D polygon offsetting, clipping, inset sidewalks, lot subdivision.
- **Install:**
  ```powershell
  vcpkg install clipper2
  ```
- **Integration:**
  - Create a `Core::Geometry::PolygonOps` wrapper that converts between `Core::Vec2` (double) and Clipper’s integer coordinates.
  - Use it in block/lot subdivision stages after road graph cycles are detected.

**Edge cases & rules:**
- **Scaling:** Decide a single global `constexpr double kClipperScale = 1000.0;` (1 mm resolution) and always map:
  - `clip_x = (int64_t)std::round(world_x * kClipperScale);`
- Guard against overflow for large worlds; if `abs(x) * scale > 9e18`, bail out or local‑recenter.
- Normalize polygons (orientation, no self‑intersections) before passing to Clipper2; add debug asserts in a `#ifndef NDEBUG` block.

***

**c) FastNoise2**

- **Use case:** Terrain base noise, small‑scale detail over your feature‑based terrain/erosion system.
- **Install:**
  ```powershell
  vcpkg install fastnoise2
  ```
- **Integration:**
  - Add a `Core::Noise::FastNoiseContext` with seeded generators keyed by `(global_seed, layer_id)`.
  - Use this only in terrain and micro‑variation passes, not as the main structural driver (that’s your feature + MDP systems).

**Edge cases:**
- FastNoise nodes are **not** inherently thread‑safe; either:
  - Provide one instance per worker thread, or
  - Guard with thin locks if you must share (prefer the former).
- For determinism across platforms, pin exact noise types and parameters, and never change default seeds silently.

***

### 2. Navigation & 3D asset stack

**a) RecastNavigation**

- **Use case:** Navmesh generation for preview (and later game‑engine export).
- **Install:**
  ```powershell
  vcpkg install recastnavigation
  ```
- **Integration:**
  - Wrap Recast/Detour in `Core::Navigation::NavmeshBuilder` that consumes chunk terrain+roads.
  - Run per‑chunk or per‑district navmesh builds asynchronously after roads + blocks + foundations exist.

**Edge cases:**
- Keep navmesh resolution coarser than your road grid to avoid pathological memory use.
- Handle tile borders: define a navmesh tile size aligned with your chunk size and use overlap borders; never rebuild global navmesh on local edits.

***

**b) tinygltf**

- **Use case:** glTF export for roads/buildings/instances and Multi‑Format Export system.
- **Install:**
  ```powershell
  vcpkg install tinygltf
  ```
- **Integration:**
  - Inside `Core::Export::GLTFExporter`, use tinygltf to write meshes, materials, and instance transforms generated by Markov frontage and building generators.
- **Edge cases:**
  - Coordinate systems: standardize on `Z up, Y forward` internally and convert to glTF’s coordinate system consistently.
  - Large scenes: use instancing and shared meshes; do not embed 10k copies of a window mesh in buffers.

***

### 3. Data I/O and simulation stack

**a) GDAL**

- **Use case:** Import/export OSM/GeoJSON/GeoTIFF heightmaps and vector data.
- **Install:**
  ```powershell
  vcpkg install gdal
  ```
- **Integration:**
  - Wall off GDAL into `Core::Import::GisImporter` and `Core::Export::GisExporter`.
  - Use only in explicit “Import/Export” commands, not in the live editor pipeline.

**Edge cases:**
- Heavy dependency; on Windows, be explicit about `GDAL_DATA` paths and runtime DLL deployment.
- Always transform to your internal “city CRS” (e.g. local metric planar coordinates) at the boundary.

***

**b) libOpenDRIVE**

- **Use case:** Export road network into OpenDRIVE for AV / traffic runtimes and esmini.
- **Install:**
  - Usually manual:
    ```powershell
    git submodule add https://github.com/esmini/libOpenDRIVE external/libOpenDRIVE
    ```
    and wire via `add_subdirectory(external/libOpenDRIVE)`.
- **Integration:**
  - Add `Core::Export::OpenDriveExporter` that:
    - Maps your `Core::Road` graph → OpenDRIVE `road` elements, using lane width and border formulas you already documented.
    - Ensures all measures (`s`, `t`) are consistent and monotonic along each road.

**Edge cases:**
- Bridges, tunnels, multi‑layer roads: OpenDRIVE handles elevations, but you need to encode vertical geometry and layer ids in lane sections; instruct Gemini not to flatten these.
- Keep ID spaces stable across exports (road, lane IDs) so esmini scenarios remain valid between iterations.

***

**c) esmini**

- **Use case:** OpenSCENARIO/OpenDRIVE simulation runtime for preview and AV testing.
- **Install:**
  - As external dep:
    ```powershell
    git submodule add https://github.com/esmini/esmini external/esmini
    ```
  - Build as shared library for embedding, or use CLI binary for subprocess integration.

- **Integration modes:**
  1. **CLI preview:** export `.xodr` + `.xosc` and launch `esmini` as a subprocess for quick verification.
  2. **Embedded:** link `esminiLib` and expose `EmbeddedSimulationView` that steps the sim in a background thread and overlays vehicles in your viewport.

**Edge cases:**
- Threading: esmini’s internal loop must not run on your render thread; keep a dedicated sim thread and poll object states.
- File lifetime: ensure temp `.xodr/.xosc` exist for the lifetime of the sim; don’t place them in auto‑cleaned temp dirs.
- Version skew: pin esmini/libOpenDRIVE versions; OpenDRIVE schema changes can silently break scenarios.

***

## Markov chains & MDPs in the architecture

Your docs already nail where Markov/MDP live: road growth and frontage profiling, layered on top of chunked generation.

### 1. Road MDP integration

**Where it lives:**
- Inside the “Layer 2: Skeleton (Roads & Graph)” stage, per‑chunk.

**Gemini instructions for implementation:**

- Create an interface:
  ```cpp
  struct RoadState {
      Core::Vec2 position;
      Core::Vec2 tangent;
      float distance_to_major;
      float local_density;
      uint8_t zone_type;
      // … other normalized features
  };

  enum class RoadAction : uint8_t {
      FOLLOW_TENSOR,
      FORCE_GRID,
      SNAP_TO_INTERSECTION,
      TERMINATE_CUL_DE_SAC,
      // future extensions
  };

  class IRoadPolicy {
  public:
      virtual RoadAction ChooseAction(const RoadState& state, uint32_t rng_seed) const = 0;
      virtual ~IRoadPolicy() = default;
  };
  ```


- Implement at least:
  - `GridPolicy`, `OrganicPolicy`, and a “debug deterministic” policy that only follows tensors.
- Wire this into your chunk road builder so the MDP:
  - Reads tensor directions from `TextureSpace` or analytic tensor field.
  - Executes actions via geometry helpers (TinySpline/Boost) to grow the graph.

**MDP edge cases:**

- **Determinism vs RNG**:
  - Seed per road front (`seed = city_seed ^ road_id ^ chunk_id`).
  - Never call RNG from static/global objects.
- **Snap actions:**
  - When `SNAP_TO_INTERSECTION`, define a robust spatial query radius and behaviour when no target found (fallback to FOLLOW_TENSOR or terminate).
- **Policy switching:**
  - As you cross district boundaries, switch `IRoadPolicy` based on HFSM zoning state; ensure state handover doesn’t cause sharp, single‑step kinks—lerp orientation constraints over a few steps.

***

### 2. Frontage Markov integration

**Where it lives:**
- After lots are generated and classified; “Layer 4: Detailing”.

**Gemini instructions:**

- Implement a data‑driven `TransitionMatrix`:

  ```cpp
  enum class FacadeModule : uint8_t {
      SHOP,
      CAFE,
      OFFICE_LOBBY,
      BLANK_WALL,
      PARKING_ENTRANCE,
      ALLEY,
      COUNT
  };

  class TransitionMatrix {
  public:
      void SetRow(FacadeModule state, gsl::span<const float> probs);
      FacadeModule SampleNext(FacadeModule current, std::mt19937& rng) const;
  private:
      std::array<std::array<float, (size_t)FacadeModule::COUNT>, (size_t)FacadeModule::COUNT> rows_;
  };
  ```

- For each zoning regime (from HFSM), load a different matrix (e.g. Commercial, Suburban, Industrial).
- In `FrontageProfiler`, walk the road‑facing edge spline of each lot, sampling modules along length and producing `PlacedModule` records (type, transform, width).

**Markov edge cases & rules:**

- Each row must sum to ~1.0; instruct Gemini to add a `Validate()` method with asserts in debug builds.
- Disallow invalid successions by zeroing probabilities (e.g. `Alley` → `Alley`).
- For finite edges, ensure termination:
  - Either accept truncation of last module, or define a special “endcap” module with high probability when remaining distance < module_width.

***

### 3. Chunking, threading, and Markov/MDP

Your hardening doc already lays out: chunked SoA, ghost margins, and worker queues.

**Gemini must:**

- Treat MDP and Markov as **pure functions of local state + seed**:
  - Inputs: local tensor samples, zoning, distance to features, chunk coord, seed.
  - Output: records (roads, placed modules) in SoA arrays owned by `ChunkData`.

- Never allow cross‑chunk writes:
  - When roads cross into neighbor chunks, emit a small connection request into neighbor’s inbound queue; never mutate neighbor data directly.

- Use SoA for performance:
  - Road & building placement should be `std::vector<Vec2>` + `std::vector<uint8_t type>` style, not vectors of structs.

***

## Gemini 3 Pro “do / don’t” checklists

### Coding behaviour

- **DO**
  - Search the repo (or ask you to paste headers) before defining any `Vec2`, `Bounds`, `Road` types.
  - Extend existing `GenerationStage`/dirty‑mask systems instead of inventing new flags.
  - Insert **small**, self‑contained methods and classes; keep public headers minimal and push complexity to .cpp.
  - Add unit tests for each new subsystem: terrain, Markov frontage, road MDP.

- **DON’T**
  - Reformat or rewrite large files wholesale; keep diffs surgical.
  - Introduce new top‑level globals or singletons; use `Editor::GlobalState` and explicit contexts.
  - Mix synchronous editor UI code with heavy generation logic; always go through your task/worker queue.

***

## Example Gemini prompts per stage

You can reuse these recipes as system/user prompts when driving Gemini 3 Pro.

### Example: Install + wire library

> “You are editing a CMake‑based C++17 project called RogueCities. We already use vcpkg. Add Clipper2 as a dependency and implement a `Core::Geometry::PolygonOps` helper for insetting block polygons into lots using `Core::Vec2` and `Core::Bounds`. Use a fixed world→integer scale and add debug assertions to validate polygon orientation. Do not change namespaces or existing types outside the new helper files.”

### Example: Implement Road MDP

> “In `RogueCity::Generators`, extend the road generation layer to support an `IRoadPolicy` MDP: the existing tensor field remains an input observation, but decisions about turning, snapping to intersections, or terminating are made by a policy. Implement a `GridPolicy` and wire it into the road builder used in chunk generation. Ensure determinism with a seed derived from `(global_seed, chunk_coord, road_id)` and keep all math in `Core::Vec2`.”

### Example: Frontage Markov

> “Add a `FrontageProfiler` module that, for each road‑facing lot edge, walks a TinySpline curve and samples facade modules using a Markov transition matrix. Each zoning regime gets its own matrix. Emit `PlacedModule` structs with type enum and transform matrix, stored in SoA arrays on the owning chunk. Rows in the matrix must sum to 1.0, assert this in debug builds.”

***

## Terminal command cheat sheet (for Gemini to assume)

Have Gemini assume these commands exist and are used between steps:

```powershell

# Install new libs via vcpkg
vcpkg install manifold clipper2 recastnavigation tinygltf fastnoise2 gdal
```


If you’d like, next step I can draft concrete CMake snippets and minimal header stubs for each new module (PolygonOps, RoadPolicy, FrontageProfiler) that you can hand directly to Gemini as starting contexts.